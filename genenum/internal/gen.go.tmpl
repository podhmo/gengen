{{- /* need: struct {Name string; Packages []string; Schemas []struct{ Prefix string; Name string; }; } */ -}}
//go:buld gen

// Code generated by gen.go.tmpl DO NOT EDIT.
package main

import (
	"encoding/json"
	"fmt"
	"log"

	"github.com/podhmo/gengen/genenum/generator/emitter"
	"github.com/podhmo/gengen/genenum/schema"
{{- range .Packages }}
	{{ . | printf "%q" }}
{{ end }}
)

func run() error {
	g, err := emitter.NewEmitter()
	if err != nil {
		return fmt.Errorf("new emitter: %w", err)
	}

	// pkg name
	pkg := {{ .Name | printf "%q" }}
	// input:
	schemas := []schema.EnumInterface{
{{- range .Schemas }}
		{{ .Prefix }}.{{ .Name }}{},
{{ end }}
	}

	targets := make([]emitter.Enum, len(schemas))

	for i, x := range schemas {
		var dst emitter.Enum
		typename := x.Name(x)

		b, err := schema.MarshalSchema(x)
		if err != nil {
			return fmt.Errorf("marshal in %v: %w", typename, err)
		}

		if err := json.Unmarshal(b, &dst); err != nil {
			return fmt.Errorf("unmarshal in %v: %w", typename, err)
		}

		// fixme: toJSON uint as float64 in marshal
		for i, v := range dst.Values {
			v.Value = uint64(v.Value.(float64))
			dst.Values[i] = v
		}

		targets[i] = dst
	}

	b, err := g.Emit(pkg, targets)
	if err != nil {
		return fmt.Errorf("emit: %w", err)
	}
	fmt.Println(string(b))
	return nil
}

func main() {
	if err := run(); err != nil {
		log.Fatalf("!! %+v", err)
	}
}
